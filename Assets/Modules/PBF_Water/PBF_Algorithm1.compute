//#pragma kernel PBF_Algorithm1
#define PI 3.14159265359f
#define ThreadGroupX 64
#define ThreadGroupY 1

struct ParticleData
{
    float3 curPosition;
    float3 nextPosition;
    float3 deltaPosition;
    float3 extForce;
    float3 velocity;
    float lambda;
};

RWStructuredBuffer<ParticleData> ParticleBuffer;
int SolverIterationTime;
float RestDensity;
int ParticleNum;
float3 Gravity;
float DeltaTime;
float TotalMass;

float InteractRadius;
float InteractRadius_SQU;
float InteractRadius_CUBE;
float DeltaQ;
float NeighborRadius;

// PBF 4.Tensile Instability parameters

float K;
float N;
float EpsilonLambda;

// XSPH Viscosity
float C;

float Poly6Term;
float SpikyTerm;

float WDeltaQ;

float4 BoundaryMax;
float4 BoundaryMin;

void CheckBoundaries(out float3 position);
void SolverIteration();
float ManhattanDistance(float3 posA, float3 posB);
float DensityEstimation(float3 posP, float3 posNeighbor);
float3 CalculateGradient(float3 posP, float3 posNeighbor);

// todo: do something about LOOPS
[numthreads(8,8,1)]
void PBF_Algorithm1 (uint3 id : SV_DispatchThreadID)
{
    // Algorithm 1 Simulation Loop:
        // Loop line 1~4: 
        //      - Apply forces
        //      - Predict position
        //      - Check Boundaries
    for(int i = 0; i < ThreadGroupX; i++)
    {
        
        ParticleBuffer[i].extForce = Gravity;
        ParticleBuffer[i].velocity += ParticleBuffer[i].extForce * DeltaTime;
        
        ParticleBuffer[i].nextPosition += ParticleBuffer[i].velocity * DeltaTime;
        
        CheckBoundaries(ParticleBuffer[i].nextPosition);
    }

        // Loop line 5~19:
    for(int i = 0; i < SolverIterationTime; i++)
    {
        // Loop line 9~11:
        //      calculate lambda for each particle
        //      ergod every particle, use nextPosition to estimate density & calculate gradient
        for(int j = 0; j < ThreadGroupX; j++)
        {
            float3 curPosition = ParticleBuffer[j].nextPosition;
            float density;
            for(int k = 0; k < ParticleNum; k++)
            {
                float3 neighborPosition = ParticleBuffer[k].nextPosition;
                if(ManhattanDistance(curPosition, neighborPosition) < NeighborRadius)
                {
                    density += TotalMass * DensityEstimation(curPosition, neighborPosition);
                }
            }
            
            float equationOfStateTerm = (density / RestDensity) - 1.0f;

            float3 gradientVectorSum;
            float gradientMagnitudeSum;

            for(int k = 0; k < ParticleNum; k++)
            {
                float3 neighborPosition = ParticleBuffer[k].nextPosition;
                if(ManhattanDistance(curPosition, neighborPosition) < NeighborRadius)
                {
                    float3 gradient = CalculateGradient(curPosition, neighborPosition) / RestDensity;
                    gradientVectorSum += gradient;
                    gradientMagnitudeSum += gradient * gradient;
                }
            }
            gradientMagnitudeSum += pow(length(gradientVectorSum), 2.0f);
            ParticleBuffer[j].lambda = -1.0f * equationOfStateTerm / (gradientMagnitudeSum + EpsilonLambda);
        }

        // Loop line12~15:
        //      calculate delta position and perform collision detection & response
        for(int j = 0; j < ParticleNum; j++)
        {
            float3 curPosition = ParticleBuffer[j].nextPosition;
            float3 deltaPosition;
            for(int k = 0; k < ParticleNum; k++)
            {
                float3 neighborPosition = ParticleBuffer[k].nextPosition;
                if(ManhattanDistance(curPosition, neighborPosition) < NeighborRadius)
                {
                    // calculate S_correction by PBF equation(13)
                    float3 sCorrection = DensityEstimation(curPosition, neighborPosition) / WDeltaQ;
                    sCorrection = -1.0f * pow(sCorrection, N) * K;
                    float lambdaCorrectionTerm = ParticleBuffer[j].lambda + ParticleBuffer[k].lambda + sCorrection;
                    float gradient = CalculateGradient(curPosition, neighborPosition);
                    float correctedGradient = gradient * lambdaCorrectionTerm;
                    deltaPosition += correctedGradient;
                }
            }
            ParticleBuffer[j].deltaPosition = deltaPosition / RestDensity;
        }

        // Loop line 16~19:
        //      update nextPosition with deltaPosition
        for(int j = 0; j < ParticleNum; j++)
        {
            ParticleBuffer[j].nextPosition = ParticleBuffer[j].nextPosition + ParticleBuffer[j].deltaPosition;
            CheckBoundaries(ParticleBuffer[j].nextPosition);
        }
    }

    // Loop line 20~24:
    //      - update velocity
    //      - apply verticity confinement & XSPH vescosity
    //      - update nextPosition to curPosition
    for(int i = 0; i < ParticleNum; i++)
    {
        float3 curPosition =  ParticleBuffer[i].curPosition;
        float3 nextPosition = ParticleBuffer[i].nextPosition;

        float3 direction = nextPosition - curPosition;
        float3 nextVelocity = direction / DeltaTime;
        ParticleBuffer[i].velocity = nextVelocity;
        
        for(int j = 0; j < ParticleNum; j++)
        {
            float3 viscosity = float3(0, 0, 0);
            float3 neighborPosition = ParticleBuffer[j].nextPosition;
            if(ManhattanDistance(nextPosition, neighborPosition))
            {
                // XSPH cescosity
                float3 relaticeVelocity = ParticleBuffer[i].velocity - ParticleBuffer[j].velocity;
                float density =  DensityEstimation(nextPosition, neighborPosition);
                float3 addedGradienVel = relaticeVelocity * density;
                viscosity += addedGradienVel;
            }
            ParticleBuffer[j].velocity += viscosity * C;
        }

        ParticleBuffer[i].curPosition = nextPosition;
    }
}

float ManhattanDistance(float3 posA, float3 posB)
{
    return abs(posA.x - posB.x) + abs(posA.y - posB.y) + abs(posA.z - posB.z);
}

float SquaredEuclideanDistance(float3 posA, float3 posB)
{
    return pow(posA.x - posB.x, 2.0f) * pow(posA.y - posB.y, 2.0f) * pow(posA.z - posB.z, 2.0f);
}

float DensityEstimation(float3 posP, float3 posNeighbor)
{
    // use Poly6 Kernel to estimate density
    float euclideanDist_SQU = SquaredEuclideanDistance(posP, posNeighbor);
    if(euclideanDist_SQU > InteractRadius_SQU || euclideanDist_SQU <= 0.0f)
    {
        return 0.0f;
    }else
    {
        return Poly6Term * pow(InteractRadius_SQU - euclideanDist_SQU, 3.0f);
    }
    
}

float3 CalculateGradient(float3 posP, float3 posNeighbor)
{
    // use Spiky Kernel to calculate gradient
    float euclideanDist_SQU = SquaredEuclideanDistance(posP, posNeighbor);
    if(euclideanDist_SQU > InteractRadius_SQU || euclideanDist_SQU <= 0.0f)
    {
        return float3(0.0f , 0.0f, 0.0f);
    }else
    {
        float euclideanDist = sqrt(euclideanDist_SQU);
        float3 offsetFromNeighbor = normalize(posP - posNeighbor);
        float term = (InteractRadius - euclideanDist) * (InteractRadius - euclideanDist) * SpikyTerm;
        return offsetFromNeighbor * term;
    }
}

void CheckBoundaries(out float3 position)
{
    position.x = position.x < BoundaryMax.x ? position.x: BoundaryMax.x - 0.001f;
    position.y = position.y < BoundaryMax.y ? position.y: BoundaryMax.y - 0.001f;
    position.z = position.z < BoundaryMax.z ? position.z: BoundaryMax.z - 0.001f;
    
    position.x = position.x > BoundaryMin.x ? position.x: BoundaryMin.x + 0.001f;
    position.y = position.y > BoundaryMin.y ? position.y: BoundaryMin.y + 0.001f;
    position.z = position.z > BoundaryMin.z ? position.z: BoundaryMin.z + 0.001f;
}
